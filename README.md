# Assessing fault-tolerant quantum advantage for k-SAT with structure

This repository allows you to generate several types of random SAT instances,
solve them with a basic backtracking solver and a more modern sat solver.
Data is collected while the basic backtracking algorithm solves the instance,
which can then be used to give an accurate indication of the quantum complexity
of a quantum backtracking algorithm (an algorithm due to Montanaro 2018,
`https://theoryofcomputing.org/articles/v014a015`), specifically the T-depth
and T-count of the quantum circuit.

Fits of the complexity of the classical solver and quantum algorithm can then
be compared. This can reveal whether the quantum backtracking algorithm scales
better than a classical solver on a certain distribution of SAT instances. In
case the quantum algorithm scales better than the classical solver, we can
estimate the runtime of a T-gate and then estimate the crossover time, i.e. how
long we need to run the algorithms before quantum outspeeds classical.

Overview of repository:

- `run_experiment.py` can be used to generate SAT instances of a given type,
  which are then solved, saving the relevant data to files into a .csv file
  in the `data/` folder. See the documentation in the file itself for precise
  usage instructions.
- `analyse_data.py` takes the .csv files in `data/`, compute fits of the
  classical and quantum complexities. The file then has function to create
  various tables and plots to compare the complexity of the algorithms.
  `run_experiment.py` to plot the measured time complexity of the classical
  solvers, and the computed T-depth and T-count of the quantum algorithm(s).
- `optimise_algorithm.py` contains some functions used to determine the optimal
  configuration of the quantum walk algorithm (i.e. determine C and number
  of repetitions).
- `data/` contains all the .csv files generated by `run_experiment.py`.
- `gate_complexity/` contains two files from the code from
  `https://doi.org/10.22331/q-2019-07-18-167` which compute the circuit
  size/depth for circuits needed to implement Grover/quantum walk queries.
- `generators-IJCAI17` contains files from
  `https://www.ijcai.org/proceedings/2017/89` that are used to generate random
  SAT instances with community structure.
- `solvers/bt` contains used backtracking solver in `bt.c` (modified from the
  solver used in `https://doi.org/10.5523/bris.19va21gun3c7629f291kmd6w37`)
  which can be compiled using the given makefile.
- `solvers/CaDiCaL` contains version 1.9.5 of the CaDiCaL SAT solver (cloned
  from `https://github.com/arminbiere/cadical`).
- `solvers/SBVA` contains the SBVA pre-processer for SAT instances, which
  conjoined with CaDiCaL 1.9.5 was the winner of the 2023 SAT competition
  (cloned from `https://github.com/hgarrereyn/SBVA`)/

# Usage

1. Build the community SAT generator by going to `generators-IJCAI17` and
   running `make`.
1. Build the backtracking sat solver by going to `solvers/bt` and running `make`.
1. Build the CaDiCaL solver by going to `solvers/CaDiCaL` and running `./configure && make`.
1. Install the dependency Eigen for SBVA by going to `solvers/SBVA` and running

```
wget https://gitlab.com/libeigen/eigen/-/archive/3.4.0/eigen-3.4.0.tar.gz
tar xf eigen-3.4.0.tar.gz
```

5. Build SBVA by going to `solvers/SBVA` and running `make`.

You are now ready go. As an example, you could run
`python3 run_experiment.py 3 10 40 50 BT random` to generate 50 random
satisfiable and 50 random unsatisfiable 3-SAT instances in 10, 11, 12, ..., 40
variables, solve them with the backtracking algorithm, and computing the
T-depth and T-count of a quantum algorithm for these instances. The data will
be saved to `data/BT-3-sat-random-10-40-50.csv` and
`data/BT-3-unsat-random-10-40-50.csv`. After creating a number of such data
files, you can run `python3 analyse_data.py` to create LaTeX tables and plots
comparing the complexity.
